==== ./crm_downloader.py ====
import logging
import time
import json
from bs4 import BeautifulSoup
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC

class CRMDownloader:
    def __init__(self, driver):
        self.driver = driver

    def load_product_data(self, filename="product_data.json"):
        try:
            with open(filename, "r", encoding="utf-8") as f:
                data = json.load(f)
            logging.info("Dane produktu wczytane z %s", filename)
            return data
        except Exception as e:
            logging.error("Błąd przy wczytywaniu danych z pliku %s: %s", filename, e)
            return {}

    def save_product_data(self, product_data, filename="product_data.json"):
        try:
            with open(filename, "w", encoding="utf-8") as f:
                json.dump(product_data, f, ensure_ascii=False, indent=4)
            logging.info("Dane produktu zapisane do pliku: %s", filename)
        except Exception as e:
            logging.error("Błąd przy zapisywaniu danych produktu do pliku: %s", e)

    def display_final_info(self, product_data):
        print("\n--- Podsumowanie danych produktu ---")
        for key, value in product_data.items():
            print(f"{key}: {value}")
        print("--- Koniec podsumowania ---")

    def wait_for_login(self, crm_url, shop_url):
        logging.info("Otwieram CRM oraz Sklep")
        self.driver.get(crm_url)
        self.driver.execute_script("window.open(arguments[0], '_blank');", shop_url)
        tabs = self.driver.window_handles
        logging.info("Otwartych zakładek: %s", tabs)

    def switch_to_crm(self):
        tabs = self.driver.window_handles
        if len(tabs) >= 1:
            self.driver.switch_to.window(tabs[0])
            logging.info("Przełączono na zakładkę CRM.")
            self.driver.switch_to.default_content()
        else:
            logging.error("Brak otwartych zakładek do przełączenia (CRM).")

    def switch_to_product_iframe(self):
        self.driver.switch_to.default_content()
        logging.info("Przełączam się na iframe z id 'contentframeprodukte'.")
        product_iframe = WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located((By.ID, "contentframeprodukte"))
        )
        self.driver.switch_to.frame(product_iframe)
        logging.info("Przełączono na iframe produktu.")

    def wait_for_product_page(self):
        logging.info("Czekam na załadowanie strony produktu (element o id 'feld44').")
        try:
            WebDriverWait(self.driver, 30).until(lambda d: len(d.find_elements(By.XPATH, "//*[@id='feld44']")) > 0)
            fields = self.driver.find_elements(By.XPATH, "//*[@id='feld44']")
            logging.info("Znaleziono %d elementów o id 'feld44'.", len(fields))
            return fields[0]
        except Exception as e:
            logging.error("Nie udało się znaleźć elementu 'feld44': %s", e)
            raise

    def fill_product_data(self):
        try:
            logging.info("Uzupełniam pole 'feld93' wartością 'Stck'.")
            feld93 = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "feld93"))
            )
            feld93.clear()
            feld93.send_keys("Stck")
            logging.info("Pole 'feld93' ustawione.")
        except Exception as e:
            logging.error("Błąd przy uzupełnianiu pola 'feld93': %s", e)
        try:
            logging.info("Uzupełniam pole 'feld94_vorne' wartością '1'.")
            feld94 = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "feld94_vorne"))
            )
            feld94.clear()
            feld94.send_keys("1")
            logging.info("Pole 'feld94_vorne' ustawione.")
        except Exception as e:
            logging.error("Błąd przy uzupełnianiu pola 'feld94_vorne': %s", e)
        try:
            logging.info("Ustawiam select 'feld99' na wartość '124'.")
            feld99 = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.NAME, "feld99"))
            )
            select_feld99 = Select(feld99)
            select_feld99.select_by_value("124")
            logging.info("Select 'feld99' ustawiony.")
        except Exception as e:
            logging.error("Błąd przy ustawianiu selecta 'feld99': %s", e)

    def click_save(self):
        try:
            logging.info("Klikam przycisk zapisu.")
            save_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "input.Buttonspeichern[name='feldspeichern']"))
            )
            save_button.click()
            logging.info("Przycisk zapisu kliknięty.")
        except Exception as e:
            logging.error("Błąd przy klikaniu przycisku zapisu: %s", e)

    def remove_inline_styles(self, html):
        soup = BeautifulSoup(html, "html.parser")
        for tag in soup.find_all(True):
            for attr in ["style", "data-mce-style"]:
                if tag.has_attr(attr):
                    del tag[attr]
        return str(soup)

    def get_product_details(self):
        product_data = {}
        try:
            logging.info("Pobieram numer produktu z pola 'feld44'.")
            new_field = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.XPATH, "//*[@id='feld44']"))
            )
            artikelnummer = new_field.get_attribute("value")
            product_data["artikelnummer"] = artikelnummer
            logging.info("Numer produktu: %s", artikelnummer)
        except Exception as e:
            logging.error("Błąd przy pobieraniu numeru produktu: %s", e)
        try:
            logging.info("Pobieram wartość opakowania z pola 'feld82_vorne'.")
            verpackungseinheit = self.driver.find_element(By.ID, "feld82_vorne").get_attribute("value")
            product_data["verpackungseinheit"] = verpackungseinheit
            logging.info("Opakowanie: %s", verpackungseinheit)
        except Exception as e:
            logging.error("Błąd przy pobieraniu opakowania: %s", e)
        try:
            logging.info("Pobieram opis produktu z iframe edytora.")
            desc_iframe = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "tri_editor_feld42_ifr"))
            )
            self.driver.switch_to.frame(desc_iframe)
            body_elem = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.TAG_NAME, "body"))
            )
            beschreibung = body_elem.get_attribute("innerHTML")
            beschreibung = self.remove_inline_styles(beschreibung)
            product_data["beschreibung"] = beschreibung
            logging.info("Opis produktu pobrany.")
            self.driver.switch_to.parent_frame()
        except Exception as e:
            logging.error("Błąd przy pobieraniu opisu produktu: %s", e)
            product_data["beschreibung"] = ""
        return product_data

    def handle_language_popup(self, product_data):
        try:
            logging.info("Klikam przycisk wyboru języka (alt='Sprachwahl').")
            lang_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//img[@alt='Sprachwahl']"))
            )
            lang_button.click()
            logging.info("Przycisk wyboru języka kliknięty.")
        except Exception as e:
            logging.error("Błąd przy klikaniu przycisku wyboru języka: %s", e)
        logging.info("Powracam do głównego kontekstu.")
        self.driver.switch_to.default_content()
        try:
            logging.info("Czekam na iframe popupu językowego (id='contentframeSprache').")
            lang_iframe = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "contentframeSprache"))
            )
            self.driver.switch_to.frame(lang_iframe)
            logging.info("Przełączono na iframe popupu językowego.")
        except Exception as e:
            logging.error("Błąd przy przełączaniu na iframe popupu językowego: %s", e)
            raise
        try:
            logging.info("Pobieram zawartość pól tytułów w popupie.")
            titel_fr_elem = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.NAME, "titel_FRA"))
            )
            product_data["titel_FRA"] = titel_fr_elem.get_attribute("value")
            logging.info("Pobrano 'titel_FRA': %s", product_data["titel_FRA"])
            titel_eng_elem = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.NAME, "titel_GBR"))
            )
            product_data["titel_GBR"] = titel_eng_elem.get_attribute("value")
            logging.info("Pobrano 'titel_GBR': %s", product_data["titel_GBR"])
        except Exception as e:
            logging.error("Błąd przy pobieraniu danych z popupu: %s", e)
        logging.info("Powracam do głównego kontekstu.")
        self.driver.switch_to.default_content()
        try:
            close_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "div#window_Sprache img.window_close"))
            )
            self.driver.execute_script("arguments[0].click();", close_button)
            logging.info("Popup zamknięty.")
        except Exception as e:
            logging.error("Błąd przy zamykaniu popupu: %s", e)
        self.driver.switch_to.default_content()

    def click_sonstige_preise(self):
        logging.info("Przełączam się na iframe 'contentframeprodukte' przed kliknięciem 'Sonstige Preise'.")
        self.driver.switch_to.frame("contentframeprodukte")
        try:
            logging.info("Czekam na element 'Sonstige Preise'.")
            sonstige_preise = WebDriverWait(self.driver, 30).until(
                EC.visibility_of_element_located((By.ID, "list_element_8"))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", sonstige_preise)
            self.driver.execute_script("arguments[0].click();", sonstige_preise)
            logging.info("'Sonstige Preise' kliknięte.")
        except Exception as e:
            logging.error("Błąd przy klikaniu 'Sonstige Preise': %s", e)
            raise

    def switch_to_frameunten(self):
        try:
            logging.info("Czekam na iframe 'frameunten'.")
            frameunten = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "frameunten"))
            )
            self.driver.switch_to.frame(frameunten)
            logging.info("Przełączono na iframe 'frameunten'.")
        except Exception as e:
            logging.error("Błąd przy przełączaniu na iframe 'frameunten': %s", e)
            raise

    def click_advanced_price_settings(self):
        try:
            logging.info("Czekam na link 'Erweiterte Preiseinstellungen'.")
            advanced_link = WebDriverWait(self.driver, 30).until(
                EC.visibility_of_element_located((By.XPATH, "//a[contains(@href, 'auswahl=preise') and contains(., 'Erweiterte Preiseinstellungen')]"))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", advanced_link)
            WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//a[contains(@href, 'auswahl=preise') and contains(., 'Erweiterte Preiseinstellungen')]"))
            )
            self.driver.execute_script("arguments[0].click();", advanced_link)
            logging.info("Kliknięto link 'Erweiterte Preiseinstellungen'.")
        except Exception as e:
            logging.error("Błąd przy klikaniu linku: %s", e)
            raise

    def get_prices(self, product_data):
        try:
            logging.info("Pobieram ceny z sekcji 'Weitere Verkaufspreise (€)'.")
            container = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.XPATH, "//div[@class='tri_box'][p[contains(., 'Weitere Verkaufspreise (€)')]]"))
            )
            # html = self.driver.page_source
            # with open("debug_before_prices.html", "w", encoding="utf-8") as f:
            #     f.write(html)
            table = container.find_element(By.XPATH, ".//div[@class='content']//table[contains(@class, 'table_listing')]")
            handler_row = table.find_element(By.XPATH, ".//tr[td[contains(., 'Händler (H)')]]")
            handler_int = handler_row.find_element(By.XPATH, ".//input[contains(@class, 'zahlenfeld_vorkomma')]").get_attribute("value")
            handler_dec = handler_row.find_element(By.XPATH, ".//input[contains(@class, 'zahlenfeld_nachkomma')]").get_attribute("value")
            handler_preis = f"{handler_int}.{handler_dec}"
            product_data["handler_preis"] = handler_preis
            logging.info("Handler preis: %s", handler_preis)
            endkunde_row = table.find_element(By.XPATH, ".//tr[td[contains(., 'Endkunden (EK)')]]")
            endkunde_int = endkunde_row.find_element(By.XPATH, ".//input[contains(@class, 'zahlenfeld_vorkomma')]").get_attribute("value")
            endkunde_dec = endkunde_row.find_element(By.XPATH, ".//input[contains(@class, 'zahlenfeld_nachkomma')]").get_attribute("value")
            endkunde_preis = f"{endkunde_int}.{endkunde_dec}"
            product_data["endkunde_preis"] = endkunde_preis
            logging.info("Endkunde preis: %s", endkunde_preis)
            self.driver.switch_to.default_content()
        except Exception as e:
            logging.error("Błąd przy pobieraniu cen: %s", e)
            raise

    def click_shopware6(self):
        self.driver.switch_to.frame("contentframeprodukte")
        logging.info("Przełączono na iframe 'contentframeprodukte'.")
        try:
            logging.info("Czekam na element 'Shopware 6'.")
            shopware6 = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.ID, "list_element_26")) # christine: 20, noihamburg: 26
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", shopware6)
            self.driver.execute_script("arguments[0].click();", shopware6)
            logging.info("'Shopware 6' kliknięty.")
        except Exception as e:
            logging.error("Błąd przy klikaniu 'Shopware 6': %s", e)
            raise

    def switch_to_shopware_frame(self):
        try:
            logging.info("Czekam na iframe 'frameunten' dla Shopware 6.")
            shopware_frame = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.XPATH, "//iframe[@id='frameunten' and contains(@src, 'shopwaresechs')]"))
            )
            logging.info("Znaleziono iframe 'frameunten'.")
            self.driver.switch_to.frame(shopware_frame)
            logging.info("Przełączono na iframe 'frameunten' dla Shopware 6.")
        except Exception as e:
            logging.error("Błąd przy przełączaniu na iframe 'frameunten': %s", e)
            raise

    def check_and_import_product(self):
        logging.info("Sprawdzam, czy produkt został już importiert.")
        try:
            WebDriverWait(self.driver, 1).until(
                EC.presence_of_element_located((By.XPATH, "//*[contains(text(), 'importiert')]"))
            )
            logging.info("Produkt już został importiert – pomijam kliknięcia.")
            return
        except Exception:
            logging.info("Produkt nie jest importiert – kontynuuję akcję.")
        try:
            logging.info("Klikam przycisk 'produktabgleich_vormerken'.")
            button_vormerken = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.NAME, "produktabgleich_vormerken"))
            )
            button_vormerken.click()
            logging.info("Przycisk 'produktabgleich_vormerken' kliknięty.")
        except Exception as e:
            logging.error("Błąd przy klikaniu 'produktabgleich_vormerken': %s", e)
            raise
        try:
            logging.info("Klikam przycisk 'produktabgleich_durchfuehren'.")
            button_durchfuehren = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.NAME, "produktabgleich_durchfuehren"))
            )
            button_durchfuehren.click()
            logging.info("Przycisk 'produktabgleich_durchfuehren' kliknięty.")
        except Exception as e:
            logging.warning("Przycisk 'produktabgleich_durchfuehren' nie został znaleziony lub nie można go kliknąć: %s", e)
        try:
            logging.info("Czekam na potwierdzenie 'importiert'.")
            WebDriverWait(self.driver, 60).until(
                EC.presence_of_element_located((By.XPATH, "//*[contains(text(), 'importiert') and contains(@style, 'color: green')]"))
            )
            logging.info("Produkt został pomyślnie importiert.")
        except Exception as e:
            logging.error("Błąd przy oczekiwaniu na potwierdzenie importu: %s", e)
            raise
        self.driver.switch_to.default_content()

    def click_produktdaten(self):
        try:
            logging.info("Klikam 'Produktdaten'.")
            self.driver.switch_to.default_content()
            self.driver.switch_to.frame("contentframeprodukte")
            scroll_container = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "td.menu_bg"))
            )
            self.driver.execute_script("arguments[0].scrollTop = 0;", scroll_container)
            produktdaten = WebDriverWait(self.driver, 30).until(
                EC.visibility_of_element_located((By.ID, "list_element_2"))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", produktdaten)
            self.driver.execute_script("arguments[0].click();", produktdaten)
            logging.info("'Produktdaten' kliknięte.")
            self.driver.switch_to.default_content()
        except Exception as e:
            logging.error("Błąd przy klikaniu 'Produktdaten': %s", e)
            self.driver.switch_to.default_content()
            raise

    def open_product(self, product_name):
        logging.info("open_product: wyszukuję '%s'", product_name)
        self.switch_to_crm()
        self.driver.switch_to.default_content()

        inp = WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located((By.ID, "tricoma_maneta_search"))
        )

        try:
            self.driver.execute_script("arguments[0].click();", inp)
        except Exception:
            logging.warning("open_product: JS click nie zadziałał, spróbuję normalnego click()")
            inp.click()

        time.sleep(0.5)

        inp = WebDriverWait(self.driver, 5).until(
            EC.element_to_be_clickable((By.ID, "tricoma_maneta_search"))
        )
        inp.clear()
        inp.send_keys(product_name)
        logging.info("open_product: wpisano w wyszukiwarkę '%s'", product_name)

        result_box = WebDriverWait(self.driver, 10).until(
            EC.visibility_of_element_located((By.ID, "maneta_search_window"))
        )

        first_link = result_box.find_element(By.CSS_SELECTOR, "a.tricoma_list_element_link")
        self.driver.execute_script("arguments[0].click();", first_link)
        logging.info("open_product: kliknięto pierwszy wynik")

        time.sleep(3)

        self.switch_to_product_iframe()
        self.wait_for_product_page()
        logging.info("open_product: strona produktu załadowana")


    def run_sequence(self):
        self.switch_to_crm()
        self.switch_to_product_iframe()
        self.wait_for_product_page()
        self.fill_product_data()
        self.click_save()
        product_data = self.get_product_details()
        self.handle_language_popup(product_data)
        self.click_sonstige_preise()
        self.switch_to_frameunten()
        self.click_advanced_price_settings()
        self.get_prices(product_data)
        self.click_shopware6()
        self.switch_to_shopware_frame()
        self.check_and_import_product()
        self.click_produktdaten()

        return product_data


==== ./driver_initializer.py ====
import logging
from selenium import webdriver
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.firefox.options import Options

class DriverInitializer:
    def __init__(self, config):
        self.config = config

    def init_driver(self):
        logging.info("Inicjalizacja Firefoksa z geckodriverem i dedykowanym profilem.")
        service = Service(self.config["GECKODRIVER_PATH"])
        options = Options()
        options.binary_location = self.config["FIREFOX_BINARY"]
        options.profile = self.config["FIREFOX_PROFILE"]
        driver = webdriver.Firefox(service=service, options=options)
        return driver


==== ./facade.py ====
import logging
from crm_downloader import CRMDownloader
from shop_uploader import ShopUploader
from translator import Translator

class ProcessFacade:
    def __init__(self, driver, config):
        self.driver = driver
        self.config = config
        self.crm_downloader = CRMDownloader(driver)
        self.shop_uploader = ShopUploader(driver)
        self.translator = Translator(config)

    def run_full_process(self):
        # Download danych z CRM
        product_data = self.crm_downloader.run_sequence()
        self.crm_downloader.save_product_data(product_data)
        # Tłumaczenie opisu
        product_data = self.translator.translate_product(product_data)
        self.crm_downloader.display_final_info(product_data)
        self.crm_downloader.save_product_data(product_data)
        # Upload do sklepu
        self.shop_uploader.go_to_shop(product_data)

        input("\nNaciśnij Enter, aby przejść do wysyłania danych do sklepu...")

        self.shop_uploader.run_sequence(product_data)
        return product_data

    def run_download_process(self):
        product_data = self.crm_downloader.run_sequence()
        self.crm_downloader.save_product_data(product_data)
        return product_data

    def run_translate_process(self):
        product_data = self.crm_downloader.load_product_data()
        product_data = self.translator.translate_product(product_data)
        self.crm_downloader.display_final_info(product_data)
        self.crm_downloader.save_product_data(product_data)
        return product_data

    def get_data(self):
        return self.crm_downloader.load_product_data()

    def go_to_shop(self):
        product_data = self.get_data()
        self.shop_uploader.go_to_shop(product_data)
        return product_data

    def run_upload_process(self):
        product_data = self.get_data()
        self.shop_uploader.run_sequence(product_data)
        return product_data

    def run_batch_process(self, filename="products.txt"):
        """
        Dla każdego produktu z pliku (jedna nazwa w linii):
          - wywołaj open_product(name)
          - wykonaj pełen proces kopiowania
        """
        try:
            with open(filename, "r", encoding="utf-8") as f:
                for line in f:
                    name = line.strip()
                    if not name:
                        continue
                    logging.info("=== Przetwarzam produkt: %s ===", name)
                    self.crm_downloader.open_product(name)
                    self.run_download_process()
                    self.run_translate_process()
                    self.go_to_shop()
                    self.run_upload_process()
            logging.info("Przetwarzanie z pliku %s zakończone.", filename)
        except Exception as e:
            logging.error("Błąd przy batchowym przetwarzaniu z pliku %s: %s", filename, e)
            raise

==== ./interface.py ====
import logging

class UserInterface:
    def __init__(self, facade):
        self.facade = facade

    def show_menu(self):
        print("Wybierz operację:")
        print("1 - Pełny proces (Download, Translate, Upload)")
        print("2 - Tylko Download i Translate")
        print("3 - Tylko Upload")
        print("4 - Przetwarzaj listę produktów z pliku")
        choice = input("Wprowadź wybór (1/2/3/4): ")
        return choice

    def execute_choice(self):
        choice = self.show_menu()
        # if choice == "1":
        #     self.facade.run_full_process()
        if choice == "1" or choice == "":
            self.facade.run_download_process()
            self.facade.run_translate_process()
            self.facade.go_to_shop()
            self.facade.run_upload_process()
        elif choice == "2":
            self.facade.run_download_process()
            self.facade.run_translate_process()
            self.facade.go_to_shop()
        elif choice == "3":
            self.facade.run_upload_process()
        elif choice == "4":
            filename = "products.txt"
            try:
                self.facade.run_batch_process(filename)
            except Exception:
                logging.error("Nie udało się przetworzyć pliku %s", filename)
        else:
            logging.error("Nieprawidłowy wybór.")

==== ./log_in.py ====
import logging
import time
import json
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC

class LogIn:
    def __init__(self, driver, tricoma, shopware):
        self.driver = driver
        self.tricoma = tricoma
        self.shopware = shopware

    def select_tricoma_login(self):
        print("Dostępni użytkownicy Tricoma:")
        users = list(self.tricoma.items())
        for idx, (key, credentials) in enumerate(users, start=1):
            print(f"{idx}: {key}")
        user_id = input("Wybierz użytkownika Tricoma: ")
        _, selected_credentials = users[int(user_id) - 1]
        return selected_credentials.get("USERNAME"), selected_credentials.get("PASSWORD")


    def select_shopware_login(self):
        print("Dostępni użytkownicy Shopware:")
        users = list(self.shopware.items())
        for idx, (key, credentials) in enumerate(users, start=1):
            print(f"{idx}: {key}")
        user_id = input("Wybierz użytkownika Shopware: ")
        _, selected_credentials = users[int(user_id) - 1]
        return selected_credentials.get("USERNAME"), selected_credentials.get("PASSWORD")


    def log_in_tricoma(self, tricoma_credentials):
        login, password = tricoma_credentials
        logging.info("Przełączam się na tricomę.")
        tabs = self.driver.window_handles
        self.driver.switch_to.window(tabs[0])
        self.driver.switch_to.default_content()
        logging.info("Przełączam się na iframe do logowania.")
        iframe = WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located((By.ID, "contentframe"))
        )
        self.driver.switch_to.frame(iframe)
        logging.info("Przełączono na iframe logowania.")
        logging.info("Wpisuję dane logowania do Tricoma.")

        try:
            user_field = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "benutzer"))
            )
            user_field.clear()
            user_field.send_keys(login)
            logging.info("Pole username ustawione.")
        except Exception as e:
            logging.error("Błąd przy uzupełnianiu pola username: %s", e)

        try:
            password_field = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "passwort"))
            )
            password_field.clear()
            password_field.send_keys(password)
            logging.info("Pole password ustawione.")
        except Exception as e:
            logging.error("Błąd przy uzupełnianiu pola password: %s", e)

        try:
            logging.info("Klikam przycisk zapisu.")
            save_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "input.login[name='submitbuton']"))
            )
            save_button.click()
            logging.info("Przycisk zapisu kliknięty.")
        except Exception as e:
            logging.error("Błąd przy klikaniu przycisku zapisu: %s", e)


    def log_in_shopware(self, shopware_credentials):
        login, password = shopware_credentials
        logging.info("Przełączam się na shopware.")
        tabs = self.driver.window_handles
        self.driver.switch_to.window(tabs[1])
        self.driver.switch_to.default_content()

        try:
            user_field = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "sw-field--username"))
            )
            user_field.clear()
            user_field.send_keys(login)
            logging.info("Pole username ustawione.")
        except Exception as e:
            logging.error("Błąd przy uzupełnianiu pola username: %s", e)

        try:
            password_field = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "sw-field--password"))
            )
            password_field.clear()
            password_field.send_keys(password)
            logging.info("Pole password ustawione.")
        except Exception as e:
            logging.error("Błąd przy uzupełnianiu pola password: %s", e)

        try:
            logging.info("Klikam przycisk zapisu.")
            save_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button.sw-login__login-action"))
            )
            save_button.click()
            logging.info("Przycisk zapisu kliknięty.")
        except Exception as e:
            logging.error("Błąd przy klikaniu przycisku zapisu: %s", e)


    def log_in(self):
        try:
            shopware_credentials = self.select_shopware_login()
            self.log_in_shopware(shopware_credentials)
            tricoma_credentials = self.select_tricoma_login()
            self.log_in_tricoma(tricoma_credentials)
        except Exception as e:
            logging.error("Błąd logowania: %s", e)
            raise

==== ./main.py ====
import logging
import json
from driver_initializer import DriverInitializer
from facade import ProcessFacade
from interface import UserInterface
from log_in import LogIn

def load_config(filename="config.json"):
    try:
        with open(filename, "r", encoding="utf-8") as f:
            config = json.load(f)
        return config
    except Exception as e:
        logging.error("Błąd przy wczytywaniu konfiguracji: %s", e)
        return {}

def main():
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    config = load_config()
    driver_init = DriverInitializer(config)
    driver = driver_init.init_driver()
    facade = ProcessFacade(driver, config)

    # Otwarcie stron

    crm_url = config.get("CRM_URL", "https://default-crm-url")
    shop_url = config.get("SHOP_URL", "https://default-shop-url")
    facade.crm_downloader.wait_for_login(crm_url, shop_url)

    # Logowanie

    tricoma_logins = config.get("TRICOMA_LOGINS", [])
    shopware_logins = config.get("SHOPWARE_LOGINS", [])

    log_in = LogIn(driver, tricoma_logins, shopware_logins)
    log_in.log_in()

    ui = UserInterface(facade)
    while True:
        ui.execute_choice()

if __name__ == "__main__":
    main()


==== ./shop_uploader.py ====
import logging
import time
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains

class ShopUploader:
    def __init__(self, driver):
        self.driver = driver

    def switch_to_shop(self):
        tabs = self.driver.window_handles
        if len(tabs) >= 2:
            self.driver.switch_to.window(tabs[1])
            logging.info("Przełączono na zakładkę Sklep.")
        else:
            logging.error("Brak otwartej drugiej zakładki (Sklep).")

    def go_to_tab(self, tab="general"):
        try:
            if tab.lower() == "general":
                logging.info("Przechodzę do zakładki General.")
                tab_element = WebDriverWait(self.driver, 20).until(
                    EC.element_to_be_clickable((
                        By.XPATH, "//a[contains(@href, '/base') and contains(@class, 'sw-product-detail__tab-general')]"
                    ))
                )
            elif tab.lower() == "advanced pricing":
                logging.info("Przechodzę do zakładki Advanced pricing.")
                tab_element = WebDriverWait(self.driver, 20).until(
                    EC.element_to_be_clickable((
                        By.XPATH, "//a[contains(@href, '/prices') and contains(@class, 'sw-product-detail__tab-advanced-prices')]"
                    ))
                )
            else:
                logging.error("Nieznana zakładka: %s", tab)
                return False
            self.driver.execute_script("arguments[0].scrollIntoView(true);", tab_element)
            self.driver.execute_script("arguments[0].click();", tab_element)
            logging.info("Przełączono na zakładkę %s.", tab)
            return True
        except Exception as e:
            logging.error("Błąd przy przełączaniu zakładki %s: %s", tab, e)
            return False

    def dump_page_source(self, file_path="page_dump.html"):
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(self.driver.page_source)
            print(f"Page source zapisany do pliku: {file_path}")
        except Exception as e:
            print(f"Błąd podczas zapisywania page source: {e}")

    def update_manufacturer_selection(self):
        try:
            logging.info("Aktualizuję wybór producenta (manufacturer).")
            manufacturer_container = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.ID, "manufacturerId"))
            )
            container = manufacturer_container.find_element(
                By.CSS_SELECTOR, "div.sw-entity-single-select__selection"
            )
            current_value = container.find_element(
                By.CSS_SELECTOR, "div.sw-entity-single-select__selection-text"
            ).text.strip()

            if current_value == "Scherer Voigt GbR":
                logging.info("Producent już jest ustawiony na 'Scherer Voigt GbR'.")
                return True

            self.driver.execute_script("arguments[0].scrollIntoView(true);", container)
            self.driver.execute_script("arguments[0].click();", container)
            logging.info("Kliknięto pole producenta - otwieram listę opcji.")

            options_container = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located(
                    (By.CSS_SELECTOR, "div.sw-select-result-list__content")
                )
            )
            options_list = options_container.find_element(
                By.CSS_SELECTOR, "ul.sw-select-result-list__item-list"
            )
            first_option = WebDriverWait(options_list, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "li.sw-select-option--0"))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", first_option)
            self.driver.execute_script("arguments[0].click();", first_option)
            logging.info("Wybrano producenta: 'Scherer Voigt GbR'.")
            return True

        except Exception as e:
            logging.error("Błąd przy aktualizacji producenta: %s", e)
            return False


    def remove_rules_added(self):
        try:
            buttons = WebDriverWait(self.driver, 3).until(
                lambda d: d.find_elements(By.XPATH, "//button[.//span[text()='Delete pricing rule']]")
            )
            count = len(buttons)
            logging.info("Znaleziono %s przycisków do usunięcia reguły cenowej.", count)
            if count == 0:
                return True

            for i in range(count):
                buttons = self.driver.find_elements(By.XPATH, "//button[.//span[text()='Delete pricing rule']]")
                if buttons:
                    button_to_remove = buttons[0]
                    self.driver.execute_script("arguments[0].scrollIntoView(true);", button_to_remove)
                    self.driver.execute_script("arguments[0].click();", button_to_remove)
                    logging.info("Kliknięto przycisk do usunięcia reguły cenowej (%s/%s).", i + 1, count)
                    time.sleep(0.5)
                else:
                    break
            return True

        except Exception as e:
            self.dump_page_source()
            logging.error("Błąd przy sprawdzaniu dodanych reguł: %s", e)
            return False


    def select_conditional_rule(self, rule_text="Händler"):
        try:
            self.dump_page_source("debug_before_prices.html")
            logging.info("Klikam w element wyboru reguły warunkowej.")
            selection_div = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.CSS_SELECTOR, "div.sw-product-detail-context-prices__empty-state-select-rule div.sw-select__selection"
                ))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", selection_div)
            self.driver.execute_script("arguments[0].click();", selection_div)
            li_option = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.XPATH, f"//li[contains(@class, 'sw-select-result') and .//div[contains(@class, 'sw-highlight-text') and text()='{rule_text}']]"
                ))
            )
            li_option.click()
            logging.info("Wybrano regułę warunkową: %s", rule_text)
            return True
        except Exception as e:
            logging.error("Błąd przy wyborze reguły warunkowej: %s", e)
            return False

    def click_add_pricing_rule(self):
        try:
            logging.info("Klikam przycisk 'Add pricing rule'.")
            add_rule_button = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.CSS_SELECTOR, "button.sw-product-detail-context-prices__add-new-rule"
                ))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", add_rule_button)
            self.driver.execute_script("arguments[0].click();", add_rule_button)
            logging.info("Przycisk 'Add pricing rule' kliknięty.")
            return True
        except Exception as e:
            logging.error("Błąd przy klikaniu 'Add pricing rule': %s", e)
            return False

    def update_handler_preis(self, product_data):
        try:
            handler_preis = product_data.get("handler_preis")
            if handler_preis is None:
                logging.error("Brak ceny 'handler_preis' w product_data.")
                return False

            # Czekamy, aż pojawią się inputy
            inputs = WebDriverWait(self.driver, 20).until(
                lambda d: d.find_elements(By.XPATH, "//input[@name='sw-price-field-net' and @aria-label='Euro']")
            )
            logging.info("Znaleziono %s inputów do aktualizacji ceny.", len(inputs))

            # Iterujemy po inputach – modyfikujemy tylko te, które mają już wpisaną wartość
            for input_field in inputs:
                current_value = input_field.get_attribute("value")
                if current_value and current_value.strip() != "":
                    input_field.clear()
                    input_field.send_keys(str(handler_preis))
                    logging.info("Zaktualizowano input (wcześniejsza wartość: %s) na: %s", current_value, handler_preis)
                else:
                    logging.info("Pominięto input, ponieważ nie ma w nim wpisanej wartości.")

            return True

        except Exception as e:
            logging.error("Błąd przy aktualizacji ceny 'handler_preis': %s", e)
            return False


    def select_pricing_rule_in_new_card(self, rule_text="Händler Ausland"):
        try:
            logging.info("Przechodzę do pola wyboru w nowej regule cenowej.")
            rule_input = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.XPATH,
                    "//div[contains(@class, 'context-price') and contains(@class, 'context-price-group-1')]//input[@placeholder='Select a conditional rule...']"
                ))
            )
            rule_input.click()
            li_option = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.XPATH,
                    f"//li[contains(@class, 'sw-select-result') and .//div[contains(@class, 'sw-highlight-text') and normalize-space(text())='{rule_text}']]"
                ))
            )
            li_option.click()
            logging.info("Wybrano regułę: %s", rule_text)
            return True
        except Exception as e:
            logging.error("Błąd przy wyborze reguły w nowej karcie: %s", e)
            return False

    def update_price_fields(self, product_data):
        try:
            endkunde_price = float(product_data.get("endkunde_preis", 0))
            gross_price = round(endkunde_price * 1.19, 2)

            adjusted_price = round(gross_price / 0.05) * 0.05

            adjusted_price = round(adjusted_price, 2)

            logging.info("Obliczona cena: %s, zaokrąglona do najbliższej wielokrotności 0.05: %s", gross_price, adjusted_price)

            gross_field = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.ID, "sw-price-field-gross"))
            )
            gross_field.clear()
            gross_field.send_keys(str(adjusted_price))
            logging.info("Gross price ustawiony na: %s", adjusted_price)
            return True
        except Exception as e:
            logging.error("Błąd przy aktualizacji pola gross price: %s", e)
            return False


    def update_scaled_values(self, product_data):
        try:
            value_to_set = str(product_data.get("verpackungseinheit", "1"))
            groups = ["Händler", "Händler Ausland"]
            for group in groups:
                row_xpath = f"//tr[contains(@class, 'sw-data-grid__row') and .//span[normalize-space(text())='{group}']]"
                row = WebDriverWait(self.driver, 20).until(
                    EC.presence_of_element_located((By.XPATH, row_xpath))
                )
                logging.info("Znaleziono wiersz dla grupy: %s", group)
                from selenium.webdriver.common.action_chains import ActionChains
                actions = ActionChains(self.driver)
                # Minimum purchase
                min_cell = row.find_element(By.XPATH, ".//td[contains(@class, 'sw-data-grid__cell--minimumPurchase')]")
                self.driver.execute_script("arguments[0].scrollIntoView(true);", min_cell)
                actions.double_click(min_cell).perform()
                logging.info("Podwójnie kliknięto Minimum purchase dla grupy: %s", group)
                min_input = WebDriverWait(min_cell, 10).until(
                    EC.visibility_of_element_located((By.XPATH, ".//input[@aria-label='Minimum purchase']"))
                )
                min_input.clear()
                min_input.send_keys(value_to_set)
                logging.info("Ustawiono Minimum purchase dla grupy '%s' na %s", group, value_to_set)
                # Scaling
                scaling_cell = row.find_element(By.XPATH, ".//td[contains(@class, 'sw-data-grid__cell--scaling')]")
                self.driver.execute_script("arguments[0].scrollIntoView(true);", scaling_cell)
                actions.double_click(scaling_cell).perform()
                logging.info("Podwójnie kliknięto Scaling dla grupy: %s", group)
                scaling_input = WebDriverWait(scaling_cell, 10).until(
                    EC.visibility_of_element_located((By.XPATH, ".//input[@aria-label='Scaling']"))
                )
                scaling_input.clear()
                scaling_input.send_keys(value_to_set)
                logging.info("Ustawiono Scaling dla grupy '%s' na %s", group, value_to_set)
            return True
        except Exception as e:
            logging.error("Błąd przy aktualizacji scaled values: %s", e)
            return False

    def update_sales_channels_selection(self):
        try:
            logging.info("Aktualizuję wybór Sales Channels.")
            container = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, "div.sw-product-category-form__visibility_field"))
            )

            actions = ActionChains(self.driver)
            while True:
                selected_items = container.find_elements(
                    By.CSS_SELECTOR, "ul.sw-select-selection-list li.sw-select-selection-list__item-holder"
                )
                if not selected_items:
                    break
                for item in selected_items:
                    try:
                        actions.move_to_element(item).perform()
                        time.sleep(0.2)
                        remove_button = item.find_element(By.CSS_SELECTOR, "button.sw-label__dismiss")
                        self.driver.execute_script("arguments[0].scrollIntoView(true);", remove_button)
                        remove_button.click()
                        logging.info("Usunięto wybrany kanał.")
                        time.sleep(0.2)
                    except Exception as e:
                        logging.error("Błąd przy usuwaniu kanału: %s", e)
            logging.info("Lista wybranych kanałów została wyczyszczona.")


            expand_button = container.find_element(
                By.CSS_SELECTOR, "div.sw-select__selection-indicators span.sw-select__select-indicator-expand"
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", expand_button)
            self.driver.execute_script("arguments[0].click();", expand_button)
            logging.info("Rozwinięto listę Sales Channels.")
            result_list = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, "div.sw-select-result-list__content"))
            )
            options_list = result_list.find_element(By.CSS_SELECTOR, "ul.sw-select-result-list__item-list")
            option_selectors = [
                "li.sw-select-result.sw-select-option--0",
                "li.sw-select-result.sw-select-option--1",
                "li.sw-select-result.sw-select-option--2",
                "li.sw-select-result.sw-select-option--3"
            ]
            for sel in option_selectors:
                option = WebDriverWait(options_list, 10).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, sel))
                )
                self.driver.execute_script("arguments[0].scrollIntoView(true);", option)
                self.driver.execute_script("arguments[0].click();", option)
                logging.info("Kliknięto opcję %s", sel)
                time.sleep(0.2)
            return True
        except Exception as e:
            logging.error("Błąd przy aktualizacji Sales Channels: %s", e)
            return False

    def save_and_change_language(self, lang):
        try:
            logging.info("Otwieram menu wyboru języka.")
            language_switch = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "div.sw-language-switch div.sw-select__selection"))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", language_switch)
            self.driver.execute_script("arguments[0].click();", language_switch)
            logging.info("Menu wyboru języka otwarte.")
            if lang.upper() == "EN":
                selector = "//li[contains(@class, 'sw-select-result') and .//div[normalize-space(text())='English']]"
                option = WebDriverWait(self.driver, 10).until(
                    EC.element_to_be_clickable((By.XPATH, selector))
                )
            elif lang.upper() == "FR":
                selector = "//li[contains(@class, 'sw-select-result') and .//div[normalize-space(text())='Français']]"
                option = WebDriverWait(self.driver, 10).until(
                    EC.element_to_be_clickable((By.XPATH, selector))
                )
            elif lang.upper() == "DE":
                selector = "li.sw-select-result.sw-select-option--0"
                option = WebDriverWait(self.driver, 10).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, selector))
                )
            else:
                logging.error("Nieznany język: %s", lang)
                return False
            self.driver.execute_script("arguments[0].scrollIntoView(true);", option)
            self.driver.execute_script("arguments[0].click();", option)
            logging.info("Wybrano język: %s", lang)
            try:
                modal_save_button = WebDriverWait(self.driver, 5).until(
                    EC.element_to_be_clickable((By.ID, "sw-language-switch-save-changes-button"))
                )
                self.driver.execute_script("arguments[0].scrollIntoView(true);", modal_save_button)
                self.driver.execute_script("arguments[0].click();", modal_save_button)
                logging.info("Kliknięto przycisk Save w modalu.")
            except Exception as modal_error:
                logging.info("Modal o niezapisanych zmianach nie pojawił się lub nie był potrzebny")
            return True
        except Exception as e:
            logging.error("Błąd w funkcji save_and_change_language: %s", e)
            return False

    def update_translated_text(self, product_data, lang):
        try:
            name_field = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.ID, "sw-field--product-name"))
            )
            name_field.clear()
            if lang.upper() == "EN":
                new_name = product_data.get("titel_GBR", "")
                new_desc = product_data.get("beschreibung_en", "")
            elif lang.upper() == "FR":
                new_name = product_data.get("titel_FRA", "")
                new_desc = product_data.get("beschreibung_fr", "")
            else:
                logging.error("Nieznany język: %s", lang)
                return False
            name_field.send_keys(new_name)
            logging.info("Ustawiono Name na: %s", new_name)
            code_button = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.XPATH, "//div[contains(@class, 'sw-text-editor-toolbar-button__icon') and .//span[contains(@class, 'icon--regular-code-xs')]]"
                ))
            )
            if "is--active" not in code_button.get_attribute("class"):
                self.driver.execute_script("arguments[0].click();", code_button)
                logging.info("Przełączono edytor na tryb kodu.")
            else:
                logging.info("Edytor już jest w trybie kodu.")
            editor_div = WebDriverWait(self.driver, 20).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "div.sw-code-editor__editor.ace_editor"))
            )
            self.driver.execute_script("ace.edit(arguments[0]).setValue(arguments[1]);", editor_div, new_desc)
            logging.info("Ustawiono Description dla języka %s.", lang)
            return True
        except Exception as e:
            logging.error("Błąd przy aktualizacji tłumaczonego tekstu: %s", e)
            return False

    def search_product(self, product_data):
        try:
            search_input = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, "input.sw-search-bar__input"))
            )
            search_input.clear()
            artikelnummer = product_data.get("artikelnummer", "")
            if not artikelnummer:
                logging.error("Brak numeru artykułu w product_data.")
                return False
            search_input.send_keys(artikelnummer)
            logging.info("Wpisano numer artykułu: %s", artikelnummer)
            time.sleep(1)
            result_link = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.XPATH, f"//a[contains(@class, 'sw-search-bar-item__link') and .//span[contains(text(), '{artikelnummer}')]]"
                ))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", result_link)
            self.driver.execute_script("arguments[0].click();", result_link)
            logging.info("Kliknięto wynik wyszukiwania dla numeru artykułu: %s", artikelnummer)
            return True
        except Exception as e:
            logging.error("Błąd przy wyszukiwaniu produktu: %s", e)
            return False

    def go_to_shop(self, product_data):
        self.switch_to_shop()
        self.search_product(product_data)

    def run_sequence(self, product_data):
        self.switch_to_shop()
        self.go_to_tab("advanced pricing")
        self.remove_rules_added()
        self.select_conditional_rule()
        self.click_add_pricing_rule()
        self.select_pricing_rule_in_new_card()
        self.update_handler_preis(product_data)
        self.go_to_tab("general")
        self.update_manufacturer_selection()
        self.update_price_fields(product_data)
        self.update_scaled_values(product_data)
        self.update_sales_channels_selection()
        self.save_and_change_language("EN")
        self.update_translated_text(product_data, "EN")
        self.save_and_change_language("FR")
        self.update_translated_text(product_data, "FR")
        self.save_and_change_language("DE")


==== ./skrypt.py ====
import os

def save_files_content_to_txt(root_folder, output_file, ignore_dirs=None):
    """Rekurencyjnie odczytuje pliki .py w folderach, z pominięciem katalogów z ignore_dirs,
    i zapisuje ich treść do pliku tekstowego."""
    ignore_dirs = set(ignore_dirs or [])

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(root_folder):
            # Usuń z listy dirs te katalogi, których nazwy są na liście ignore_dirs
            dirs[:] = [d for d in dirs if d not in ignore_dirs]

            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            outfile.write(f"==== {file_path} ====\n")
                            outfile.write(infile.read())
                            outfile.write("\n\n")
                    except Exception as e:
                        print(f"Nie udało się odczytać pliku {file_path}: {e}")

if __name__ == "__main__":
    # Ścieżka, którą chcesz przeszukać
    input_folder = "./"
    output_file = "output.txt"
    # Tutaj wpisz nazwy folderów (tylko nazwa, nie ścieżka), które chcesz pominąć
    ignore_list = ['venv', '__pycache__', 'build']

    save_files_content_to_txt(input_folder, output_file, ignore_dirs=ignore_list)
    print(f"Zawartość plików została zapisana do {output_file}, z pominięciem katalogów: {ignore_list}")


==== ./translator.py ====
import logging
import deepl

class Translator:
    def __init__(self, config):
        self.auth_key = config["DEEPL_AUTH_KEY"]
        self.translator = deepl.Translator(self.auth_key)

    def translate_text(self, text, target_lang):
        try:
            result = self.translator.translate_text(text, target_lang=target_lang, tag_handling="html")
            logging.info("Tłumaczenie na %s zakończone.", target_lang)
            return result.text
        except Exception as e:
            logging.error("Błąd podczas tłumaczenia na %s: %s", target_lang, e)
            return ""

    def translate_product(self, product_data):
        description = product_data.get("beschreibung", "")
        if description:
            product_data["beschreibung_en"] = self.translate_text(description, "EN-GB")
            product_data["beschreibung_fr"] = self.translate_text(description, "FR")
        else:
            logging.warning("Brak opisu produktu do tłumaczenia.")
        return product_data


