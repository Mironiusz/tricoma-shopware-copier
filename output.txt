==== ./crm_downloader.py ====
import logging
import time
import json
from bs4 import BeautifulSoup
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC

class CRMDownloader:
    def __init__(self, driver):
        self.driver = driver

    def load_product_data(self, filename="product_data.json"):
        try:
            with open(filename, "r", encoding="utf-8") as f:
                data = json.load(f)
            logging.info("Product data loaded from %s", filename)
            return data
        except Exception as e:
            logging.error("Error loading data from file %s: %s", filename, e)
            return {}

    def save_product_data(self, product_data, filename="product_data.json"):
        try:
            with open(filename, "w", encoding="utf-8") as f:
                json.dump(product_data, f, ensure_ascii=False, indent=4)
            logging.info("Product data saved to file: %s", filename)
        except Exception as e:
            logging.error("Error saving product data to file: %s", e)

    def display_final_info(self, product_data):
        print("\n--- Product data summary ---")
        for key, value in product_data.items():
            print(f"{key}: {value}")
        print("--- End of summary ---")

    def wait_for_login(self, crm_url, shop_url):
        logging.info("Opening CRM and shop")
        self.driver.get(crm_url)
        self.driver.execute_script("window.open(arguments[0], '_blank');", shop_url)
        tabs = self.driver.window_handles
        logging.info("Open tabs: %s", tabs)

    def switch_to_crm(self):
        tabs = self.driver.window_handles
        if len(tabs) >= 1:
            self.driver.switch_to.window(tabs[0])
            logging.info("Switched to CRM tab.")
            self.driver.switch_to.default_content()
        else:
            logging.error("No open tabs to switch to (CRM).")

    def switch_to_product_iframe(self):
        self.driver.switch_to.default_content()
        logging.info("Switching to iframe with id 'contentframeprodukte'.")
        product_iframe = WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located((By.ID, "contentframeprodukte"))
        )
        self.driver.switch_to.frame(product_iframe)
        logging.info("Switched to product iframe.")

    def wait_for_product_page(self):
        logging.info("Waiting for product page to load (element with id 'feld44').")
        try:
            WebDriverWait(self.driver, 30).until(lambda d: len(d.find_elements(By.XPATH, "//*[@id='feld44']")) > 0)
            fields = self.driver.find_elements(By.XPATH, "//*[@id='feld44']")
            logging.info("Found %d elements with id 'feld44'.", len(fields))
            return fields[0]
        except Exception as e:
            logging.error("Failed to find element 'feld44': %s", e)
            raise

    def fill_product_data(self):
        try:
            logging.info("Filling 'feld93' with value 'Stck'.")
            feld93 = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "feld93"))
            )
            feld93.clear()
            feld93.send_keys("Stck")
            logging.info("Field 'feld93' set.")
        except Exception as e:
            logging.error("Error filling field 'feld93': %s", e)
        try:
            logging.info("Filling 'feld94_vorne' with value '1'.")
            feld94 = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "feld94_vorne"))
            )
            feld94.clear()
            feld94.send_keys("1")
            logging.info("Field 'feld94_vorne' set.")
        except Exception as e:
            logging.error("Error filling field 'feld94_vorne': %s", e)
        try:
            logging.info("Setting select 'feld99' to value '124'.")
            feld99 = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.NAME, "feld99"))
            )
            select_feld99 = Select(feld99)
            select_feld99.select_by_value("124")
            logging.info("Select 'feld99' set.")
        except Exception as e:
            logging.error("Error setting select 'feld99': %s", e)

    def click_save(self):
        try:
            logging.info("Clicking save button.")
            save_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "input.Buttonspeichern[name='feldspeichern']"))
            )
            save_button.click()
            logging.info("Save button clicked.")
        except Exception as e:
            logging.error("Error clicking save button: %s", e)

    def remove_inline_styles(self, html):
        soup = BeautifulSoup(html, "html.parser")
        for tag in soup.find_all(True):
            for attr in ["style", "data-mce-style"]:
                if tag.has_attr(attr):
                    del tag[attr]
        return str(soup)

    def get_product_details(self):
        product_data = {}
        try:
            logging.info("Retrieving product number from 'feld44'.")
            new_field = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.XPATH, "//*[@id='feld44']"))
            )
            artikelnummer = new_field.get_attribute("value")
            product_data["artikelnummer"] = artikelnummer
            logging.info("Product number: %s", artikelnummer)
        except Exception as e:
            logging.error("Error retrieving product number: %s", e)
        try:
            logging.info("Retrieving packaging unit from 'feld82_vorne'.")
            verpackungseinheit = self.driver.find_element(By.ID, "feld82_vorne").get_attribute("value")
            product_data["verpackungseinheit"] = verpackungseinheit
            logging.info("Packaging unit: %s", verpackungseinheit)
        except Exception as e:
            logging.error("Error retrieving packaging unit: %s", e)
        try:
            logging.info("Retrieving product description from editor iframe.")
            desc_iframe = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "tri_editor_feld42_ifr"))
            )
            self.driver.switch_to.frame(desc_iframe)
            body_elem = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.TAG_NAME, "body"))
            )
            beschreibung = body_elem.get_attribute("innerHTML")
            beschreibung = self.remove_inline_styles(beschreibung)
            product_data["beschreibung"] = beschreibung
            logging.info("Product description retrieved.")
            self.driver.switch_to.parent_frame()
        except Exception as e:
            logging.error("Error retrieving product description: %s", e)
            product_data["beschreibung"] = ""
        return product_data

    def handle_language_popup(self, product_data):
        try:
            logging.info("Clicking language selection button (alt='Sprachwahl').")
            lang_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//img[@alt='Sprachwahl']"))
            )
            lang_button.click()
            logging.info("Language selection button clicked.")
        except Exception as e:
            logging.error("Error clicking language selection button: %s", e)
        logging.info("Returning to main context.")
        self.driver.switch_to.default_content()
        try:
            logging.info("Waiting for language popup iframe (id='contentframeSprache').")
            lang_iframe = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "contentframeSprache"))
            )
            self.driver.switch_to.frame(lang_iframe)
            logging.info("Switched to language popup iframe.")
        except Exception as e:
            logging.error("Error switching to language popup iframe: %s", e)
            raise
        try:
            logging.info("Retrieving title fields from popup.")
            titel_fr_elem = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.NAME, "titel_FRA"))
            )
            product_data["titel_FRA"] = titel_fr_elem.get_attribute("value")
            logging.info("Retrieved 'titel_FRA': %s", product_data["titel_FRA"])
            titel_eng_elem = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.NAME, "titel_GBR"))
            )
            product_data["titel_GBR"] = titel_eng_elem.get_attribute("value")
            logging.info("Retrieved 'titel_GBR': %s", product_data["titel_GBR"])
        except Exception as e:
            logging.error("Error retrieving data from popup: %s", e)
        logging.info("Returning to main context.")
        self.driver.switch_to.default_content()
        try:
            close_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "div#window_Sprache img.window_close"))
            )
            self.driver.execute_script("arguments[0].click();", close_button)
            logging.info("Popup closed.")
        except Exception as e:
            logging.error("Error closing popup: %s", e)
        self.driver.switch_to.default_content()

    def click_sonstige_preise(self):
        logging.info("Switching to iframe 'contentframeprodukte' before clicking 'Sonstige Preise'.")
        self.driver.switch_to.frame("contentframeprodukte")
        try:
            logging.info("Waiting for list item containing text 'Sonstige Preise'.")
            xpath = "//li[.//span[contains(normalize-space(), 'Sonstige Preise')]]"
            sonstige_preise = WebDriverWait(self.driver, 30).until(
                EC.visibility_of_element_located((By.XPATH, xpath))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", sonstige_preise)
            self.driver.execute_script("arguments[0].click();", sonstige_preise)
            logging.info("'Sonstige Preise' clicked.")
        except Exception as e:
            logging.error("Error clicking 'Sonstige Preise': %s", e)
            raise

    def switch_to_frameunten(self):
        try:
            logging.info("Waiting for iframe 'frameunten'.")
            frameunten = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "frameunten"))
            )
            self.driver.switch_to.frame(frameunten)
            logging.info("Switched to iframe 'frameunten'.")
        except Exception as e:
            logging.error("Error switching to iframe 'frameunten': %s", e)
            raise

    def click_advanced_price_settings(self):
        try:
            logging.info("Waiting for 'Erweiterte Preiseinstellungen' link.")
            advanced_link = WebDriverWait(self.driver, 30).until(
                EC.visibility_of_element_located((By.XPATH, "//a[contains(@href, 'auswahl=preise') and contains(., 'Erweiterte Preiseinstellungen')]"))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", advanced_link)
            WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//a[contains(@href, 'auswahl=preise') and contains(., 'Erweiterte Preiseinstellungen')]"))
            )
            self.driver.execute_script("arguments[0].click();", advanced_link)
            logging.info("'Erweiterte Preiseinstellungen' clicked.")
        except Exception as e:
            logging.error("Error clicking link: %s", e)
            raise

    def get_prices(self, product_data):
        try:
            logging.info("Retrieving prices from 'Weitere Verkaufspreise (€)' section.")
            container = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.XPATH, "//div[@class='tri_box'][p[contains(., 'Weitere Verkaufspreise (€)')]]"))
            )
            table = container.find_element(By.XPATH, ".//div[@class='content']//table[contains(@class, 'table_listing')]")
            handler_row = table.find_element(By.XPATH, ".//tr[td[contains(., 'Händler (H)')]]")
            handler_int = handler_row.find_element(By.XPATH, ".//input[contains(@class, 'zahlenfeld_vorkomma')]").get_attribute("value")
            handler_dec = handler_row.find_element(By.XPATH, ".//input[contains(@class, 'zahlenfeld_nachkomma')]").get_attribute("value")
            handler_preis = f"{handler_int}.{handler_dec}"
            product_data["handler_preis"] = handler_preis
            logging.info("Handler preis: %s", handler_preis)
            endkunde_row = table.find_element(By.XPATH, ".//tr[td[contains(., 'Endkunden (EK)')]]")
            endkunde_int = endkunde_row.find_element(By.XPATH, ".//input[contains(@class, 'zahlenfeld_vorkomma')]").get_attribute("value")
            endkunde_dec = endkunde_row.find_element(By.XPATH, ".//input[contains(@class, 'zahlenfeld_nachkomma')]").get_attribute("value")
            endkunde_preis = f"{endkunde_int}.{endkunde_dec}"
            product_data["endkunde_preis"] = endkunde_preis
            logging.info("Endkunde preis: %s", endkunde_preis)
            self.driver.switch_to.default_content()
        except Exception as e:
            logging.error("Error retrieving prices: %s", e)
            raise

    def click_shopware6(self):
        logging.info("Switching to iframe 'contentframeprodukte' before clicking 'Shopware 6'.")
        self.driver.switch_to.frame("contentframeprodukte")

        try:
            logging.info("Waiting for list item containing text 'Shopware 6'.")
            xpath = "//li[.//span[contains(normalize-space(), 'Shopware 6')]]"
            shopware6 = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, xpath))
            )

            self.driver.execute_script("arguments[0].scrollIntoView(true);", shopware6)
            self.driver.execute_script("arguments[0].click();", shopware6)
            logging.info("'Shopware 6' clicked.")
        except Exception as e:
            logging.error("Error clicking 'Shopware 6': %s", e)
            raise

    def switch_to_shopware_frame(self):
        try:
            logging.info("Waiting for iframe 'frameunten' for Shopware 6.")
            shopware_frame = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.XPATH, "//iframe[@id='frameunten' and contains(@src, 'shopwaresechs')]"))
            )
            logging.info("Found iframe 'frameunten'.")
            self.driver.switch_to.frame(shopware_frame)
            logging.info("Switched to iframe 'frameunten' for Shopware 6.")
        except Exception as e:
            logging.error("Error switching to iframe 'frameunten': %s", e)
            raise

    def check_and_import_product(self):
        logging.info("Checking if product has already been importiert.")
        try:
            WebDriverWait(self.driver, 1).until(
                EC.presence_of_element_located((By.XPATH, "//*[contains(text(), 'importiert')]"))
            )
            logging.info("Product already importiert – skipping clicks.")
            return
        except Exception:
            logging.info("Product not importiert – continuing actions.")
        try:
            logging.info("Clicking 'produktabgleich_vormerken' button.")
            button_vormerken = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.NAME, "produktabgleich_vormerken"))
            )
            button_vormerken.click()
            logging.info("'produktabgleich_vormerken' clicked.")
        except Exception as e:
            logging.error("Error clicking 'produktabgleich_vormerken': %s", e)
            raise
        try:
            logging.info("Clicking 'produktabgleich_durchfuehren' button.")
            button_durchfuehren = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.NAME, "produktabgleich_durchfuehren"))
            )
            button_durchfuehren.click()
            logging.info("'produktabgleich_durchfuehren' clicked.")
        except Exception as e:
            logging.warning("'produktabgleich_durchfuehren' not found or not clickable: %s", e)
        try:
            logging.info("Waiting for confirmation 'importiert'.")
            WebDriverWait(self.driver, 60).until(
                EC.presence_of_element_located((By.XPATH, "//*[contains(text(), 'importiert') and contains(@style, 'color: green')]"))
            )
            logging.info("Product successfully importiert.")
        except Exception as e:
            logging.error("Error waiting for import confirmation: %s", e)
            raise
        self.driver.switch_to.default_content()

    def click_produktdaten(self):
        try:
            logging.info("Switching to default content and iframe 'contentframeprodukte' before clicking 'Produktdaten'.")
            self.driver.switch_to.default_content()
            self.driver.switch_to.frame("contentframeprodukte")

            scroll_container = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "td.menu_bg"))
            )
            self.driver.execute_script("arguments[0].scrollTop = 0;", scroll_container)

            logging.info("Waiting for list item containing text 'Produktdaten'.")
            xpath = "//li[.//span[contains(normalize-space(), 'Produktdaten')]]"
            produktdaten = WebDriverWait(self.driver, 30).until(
                EC.element_to_be_clickable((By.XPATH, xpath))
            )

            self.driver.execute_script("arguments[0].scrollIntoView(true);", produktdaten)
            self.driver.execute_script("arguments[0].click();", produktdaten)
            logging.info("'Produktdaten' clicked.")

            self.driver.switch_to.default_content()

        except Exception as e:
            logging.error("Error clicking 'Produktdaten': %s", e)
            self.driver.switch_to.default_content()
            raise

    def open_product(self, product_name):
        logging.info("open_product: searching for '%s'", product_name)
        self.switch_to_crm()
        self.driver.switch_to.default_content()

        inp = WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located((By.ID, "tricoma_maneta_search"))
        )

        try:
            self.driver.execute_script("arguments[0].click();", inp)
        except Exception:
            logging.warning("open_product: JS click failed, trying normal click()")
            inp.click()

        time.sleep(0.5)

        inp = WebDriverWait(self.driver, 5).until(
            EC.element_to_be_clickable((By.ID, "tricoma_maneta_search"))
        )
        inp.clear()
        inp.send_keys(product_name)
        logging.info("open_product: entered '%s' in search", product_name)

        result_box = WebDriverWait(self.driver, 10).until(
            EC.visibility_of_element_located((By.ID, "maneta_search_window"))
        )

        first_link = result_box.find_element(By.CSS_SELECTOR, "a.tricoma_list_element_link")
        self.driver.execute_script("arguments[0].click();", first_link)
        logging.info("open_product: clicked first result")

        time.sleep(3)

        self.switch_to_product_iframe()
        self.wait_for_product_page()
        logging.info("open_product: product page loaded")

    def run_sequence(self):
        self.switch_to_crm()
        self.switch_to_product_iframe()
        self.click_produktdaten()
        self.switch_to_product_iframe()
        self.wait_for_product_page()
        self.fill_product_data()
        self.click_save()
        product_data = self.get_product_details()
        self.handle_language_popup(product_data)
        self.click_sonstige_preise()
        self.switch_to_frameunten()
        self.click_advanced_price_settings()
        self.get_prices(product_data)
        self.click_shopware6()
        self.switch_to_shopware_frame()
        self.check_and_import_product()
        self.click_produktdaten()

        return product_data


==== ./driver_initializer.py ====
import logging
from selenium import webdriver
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.firefox.options import Options

class DriverInitializer:
    def __init__(self, config):
        self.config = config

    def init_driver(self):
        logging.info("Initializing Firefox with geckodriver and dedicated profile.")
        service = Service(self.config["GECKODRIVER_PATH"])
        options = Options()
        options.binary_location = self.config["FIREFOX_BINARY"]
        options.profile = self.config["FIREFOX_PROFILE"]
        driver = webdriver.Firefox(service=service, options=options)
        return driver


==== ./facade.py ====
import time
import logging
import os
from crm_downloader import CRMDownloader
from shop_uploader import ShopUploader
from translator import Translator

class ProcessFacade:
    def __init__(self, driver, config):
        self.driver = driver
        self.config = config
        self.crm_downloader = CRMDownloader(driver)
        self.shop_uploader = ShopUploader(driver)
        self.translator = Translator(config)

    def run_full_process(self):
        # Download data from CRM
        product_data = self.crm_downloader.run_sequence()
        self.crm_downloader.save_product_data(product_data)
        # Translate description
        product_data = self.translator.translate_product(product_data)
        self.crm_downloader.display_final_info(product_data)
        self.crm_downloader.save_product_data(product_data)
        # Upload to shop
        self.shop_uploader.go_to_shop(product_data)

        input("\nPress Enter to proceed with sending data to the shop...")

        self.shop_uploader.run_sequence(product_data)
        return product_data

    def run_download_process(self):
        product_data = self.crm_downloader.run_sequence()
        self.crm_downloader.save_product_data(product_data)
        return product_data

    def run_translate_process(self):
        product_data = self.crm_downloader.load_product_data()
        product_data = self.translator.translate_product(product_data)
        self.crm_downloader.display_final_info(product_data)
        self.crm_downloader.save_product_data(product_data)
        return product_data

    def get_data(self):
        return self.crm_downloader.load_product_data()

    def go_to_shop(self):
        product_data = self.get_data()
        self.shop_uploader.go_to_shop(product_data)
        return product_data

    def run_upload_process(self):
        product_data = self.get_data()
        self.shop_uploader.run_sequence(product_data)
        return product_data

    def run_batch_process(self,
                          filename="products.txt",
                          counter_file="product_counter.txt",
                          pause_file="pause.txt"):
        """
        For each product from the file (one name per line):
          - call open_product(name)
          - execute the full copy process
          - remove the line from the file
          - update counter and run time
          - check pause.txt and possibly break
        """

        # --- Initialize counter and start time ---
        processed_count = 0
        start_time = time.time()

        if os.path.exists(counter_file):
            try:
                with open(counter_file, "r", encoding="utf-8") as cf:
                    lines = cf.read().splitlines()
                processed_count = int(lines[0])
                h, m, s = map(int, lines[1].split(":"))
                elapsed_before = h * 3600 + m * 60 + s
                start_time = time.time() - elapsed_before
                logging.info(
                    "Loaded state from %s: %d products, previous time: %s",
                    counter_file, processed_count, lines[1]
                )
            except Exception:
                logging.warning(
                    "Failed to load %s — counter reset.", counter_file
                )
                processed_count = 0
                start_time = time.time()

        # --- Load list of products ---
        try:
            with open(filename, "r", encoding="utf-8") as f:
                all_lines = [line.strip() for line in f if line.strip()]
        except FileNotFoundError:
            logging.error("File %s does not exist.", filename)
            return

        remaining = all_lines.copy()

        # --- Main batch loop ---
        for name in all_lines:
            logging.info("=== Processing product: %s ===", name)

            # 1) Open/search
            self.crm_downloader.open_product(name)
            # 2) Download, translate, upload
            self.run_download_process()
            self.run_translate_process()
            self.go_to_shop()
            self.run_upload_process()

            # --- After successful upload ---
            processed_count += 1

            # Remove from remaining and overwrite products.txt
            remaining.remove(name)
            with open(filename, "w", encoding="utf-8") as f:
                for r in remaining:
                    f.write(r + "\n")

            # Calculate and save counter + elapsed time
            elapsed = int(time.time() - start_time)
            h, rem = divmod(elapsed, 3600)
            m, s = divmod(rem, 60)
            elapsed_str = f"{h:02d}:{m:02d}:{s:02d}"

            with open(counter_file, "w", encoding="utf-8") as cf:
                cf.write(f"{processed_count}\n")
                cf.write(elapsed_str + "\n")

            logging.info(
                "Processed %d products; runtime: %s",
                processed_count, elapsed_str
            )

            # --- Check pause.txt ---
            try:
                with open(pause_file, "r", encoding="utf-8") as pf:
                    content = pf.read().strip()
                if content == "-":
                    logging.info(
                        "Found '-' in %s — aborting batch and returning to menu.",
                        pause_file
                    )
                    return
            except FileNotFoundError:
                # file does not exist → continue batch
                pass
            except Exception as e:
                logging.warning(
                    "Failed to read %s (%s) — batch continues.",
                    pause_file, e
                )

        logging.info("Processing from file %s completed.", filename)


==== ./interface.py ====
import logging

class UserInterface:
    def __init__(self, facade):
        self.facade = facade

    def show_menu(self):
        print("Choose an operation:")
        print("1 - Full process (Download, Translate, Upload)")
        print("2 - Download and Translate only")
        print("3 - Upload only")
        print("4 - Process product list from file")
        choice = input("Enter your choice (1/2/3/4): ")
        return choice

    def execute_choice(self):
        choice = self.show_menu()
        # if choice == "1":
        #     self.facade.run_full_process()
        if choice == "1" or choice == "":
            self.facade.run_download_process()
            self.facade.run_translate_process()
            self.facade.go_to_shop()
            self.facade.run_upload_process()
        elif choice == "2":
            self.facade.run_download_process()
            self.facade.run_translate_process()
            self.facade.go_to_shop()
        elif choice == "3":
            self.facade.run_upload_process()
        elif choice == "4":
            filename = "products.txt"
            try:
                self.facade.run_batch_process(filename)
            except Exception:
                logging.error("Failed to process file %s", filename)
        else:
            logging.error("Invalid choice.")


==== ./log_in.py ====
import logging
import time
import json
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC

class LogIn:
    def __init__(self, driver, tricoma, shopware):
        self.driver = driver
        self.tricoma = tricoma
        self.shopware = shopware
        self.number = None

    def select_tricoma_login(self):
        print("Available Tricoma users:")
        users = list(self.tricoma.items())
        for idx, (key, credentials) in enumerate(users, start=1):
            print(f"{idx}: {key}")
        user_id = input("Choose Tricoma user: ")
        _, selected_credentials = users[int(user_id) - 1]
        return selected_credentials.get("USERNAME"), selected_credentials.get("PASSWORD")

    def select_shopware_login(self):
        print("Available Shopware users:")
        users = list(self.shopware.items())
        for idx, (key, credentials) in enumerate(users, start=1):
            print(f"{idx}: {key}")
        user_id = input("Choose Shopware user: ")
        _, selected_credentials = users[int(user_id) - 1]
        return selected_credentials.get("USERNAME"), selected_credentials.get("PASSWORD")

    def log_in_tricoma(self, tricoma_credentials):
        login, password = tricoma_credentials
        with open("plik.txt", "w", encoding="utf-8") as f:
            f.write(login)
        logging.info("Switching to Tricoma.")
        tabs = self.driver.window_handles
        self.driver.switch_to.window(tabs[0])
        self.driver.switch_to.default_content()
        logging.info("Switching to login iframe.")
        iframe = WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located((By.ID, "contentframe"))
        )
        self.driver.switch_to.frame(iframe)
        logging.info("Switched to login iframe.")
        logging.info("Entering Tricoma login credentials.")

        try:
            user_field = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "benutzer"))
            )
            user_field.clear()
            user_field.send_keys(login)
            logging.info("Username field set.")
        except Exception as e:
            logging.error("Error filling username field: %s", e)

        try:
            password_field = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "passwort"))
            )
            password_field.clear()
            password_field.send_keys(password)
            logging.info("Password field set.")
        except Exception as e:
            logging.error("Error filling password field: %s", e)

        try:
            logging.info("Clicking submit button.")
            save_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "input.login[name='submitbuton']"))
            )
            save_button.click()
            logging.info("Submit button clicked.")
        except Exception as e:
            logging.error("Error clicking submit button: %s", e)

    def log_in_shopware(self, shopware_credentials):
        login, password = shopware_credentials

        logging.info("Switching to Shopware.")
        tabs = self.driver.window_handles
        self.driver.switch_to.window(tabs[1])
        self.driver.switch_to.default_content()

        try:
            user_field = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "sw-field--username"))
            )
            user_field.clear()
            user_field.send_keys(login)
            logging.info("Username field set.")
        except Exception as e:
            logging.error("Error filling username field: %s", e)

        try:
            password_field = WebDriverWait(self.driver, 10).until(
                EC.presence_of_element_located((By.ID, "sw-field--password"))
            )
            password_field.clear()
            password_field.send_keys(password)
            logging.info("Password field set.")
        except Exception as e:
            logging.error("Error filling password field: %s", e)

        try:
            logging.info("Clicking submit button.")
            save_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button.sw-login__login-action"))
            )
            save_button.click()
            logging.info("Submit button clicked.")
        except Exception as e:
            logging.error("Error clicking submit button: %s", e)

    def log_in(self):
        try:
            shopware_credentials = self.select_shopware_login()
            self.log_in_shopware(shopware_credentials)
            tricoma_credentials = self.select_tricoma_login()
            self.log_in_tricoma(tricoma_credentials)
        except Exception as e:
            logging.error("Login error: %s", e)
            raise


==== ./main.py ====
import logging
import json
from driver_initializer import DriverInitializer
from facade import ProcessFacade
from interface import UserInterface
from log_in import LogIn

def load_config(filename="config.json"):
    try:
        with open(filename, "r", encoding="utf-8") as f:
            config = json.load(f)
        return config
    except Exception as e:
        logging.error("Błąd przy wczytywaniu konfiguracji: %s", e)
        return {}

def main():
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    config = load_config()
    driver_init = DriverInitializer(config)
    driver = driver_init.init_driver()
    facade = ProcessFacade(driver, config)

    # Otwarcie stron

    crm_url = config.get("CRM_URL", "https://default-crm-url")
    shop_url = config.get("SHOP_URL", "https://default-shop-url")
    facade.crm_downloader.wait_for_login(crm_url, shop_url)

    # Logowanie

    tricoma_logins = config.get("TRICOMA_LOGINS", [])
    shopware_logins = config.get("SHOPWARE_LOGINS", [])

    log_in = LogIn(driver, tricoma_logins, shopware_logins)
    log_in.log_in()

    ui = UserInterface(facade)
    while True:
        ui.execute_choice()

if __name__ == "__main__":
    main()


==== ./shop_uploader.py ====
import logging
import time
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains

class ShopUploader:
    def __init__(self, driver):
        self.driver = driver

    def switch_to_shop(self):
        tabs = self.driver.window_handles
        if len(tabs) >= 2:
            self.driver.switch_to.window(tabs[1])
            logging.info("Switched to Shop tab.")
        else:
            logging.error("No second tab open (Shop).")

    def go_to_tab(self, tab="general"):
        try:
            if tab.lower() == "general":
                logging.info("Navigating to General tab.")
                tab_element = WebDriverWait(self.driver, 20).until(
                    EC.element_to_be_clickable((
                        By.XPATH, "//a[contains(@href, '/base') and contains(@class, 'sw-product-detail__tab-general')]"
                    ))
                )
            elif tab.lower() == "advanced pricing":
                logging.info("Navigating to Advanced pricing tab.")
                tab_element = WebDriverWait(self.driver, 20).until(
                    EC.element_to_be_clickable((
                        By.XPATH, "//a[contains(@href, '/prices') and contains(@class, 'sw-product-detail__tab-advanced-prices')]"
                    ))
                )
            else:
                logging.error("Unknown tab: %s", tab)
                return False
            self.driver.execute_script("arguments[0].scrollIntoView(true);", tab_element)
            self.driver.execute_script("arguments[0].click();", tab_element)
            logging.info("Switched to tab %s.", tab)
            return True
        except Exception as e:
            logging.error("Error switching to tab %s: %s", tab, e)
            return False

    def dump_page_source(self, file_path="page_dump.html"):
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(self.driver.page_source)
            print(f"Page source saved to file: {file_path}")
        except Exception as e:
            print(f"Error saving page source: {e}")

    def update_manufacturer_selection(self):
        try:
            logging.info("Updating manufacturer selection.")
            manufacturer_container = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.ID, "manufacturerId"))
            )
            container = manufacturer_container.find_element(
                By.CSS_SELECTOR, "div.sw-entity-single-select__selection"
            )
            current_value = container.find_element(
                By.CSS_SELECTOR, "div.sw-entity-single-select__selection-text"
            ).text.strip()

            if current_value == "Scherer Voigt GbR":
                logging.info("Manufacturer already set to 'Scherer Voigt GbR'.")
                return True

            self.driver.execute_script("arguments[0].scrollIntoView(true);", container)
            self.driver.execute_script("arguments[0].click();", container)
            logging.info("Clicked manufacturer field to open options.")

            options_container = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located(
                    (By.CSS_SELECTOR, "div.sw-select-result-list__content")
                )
            )
            options_list = options_container.find_element(
                By.CSS_SELECTOR, "ul.sw-select-result-list__item-list"
            )
            first_option = WebDriverWait(options_list, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "li.sw-select-option--0"))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", first_option)
            self.driver.execute_script("arguments[0].click();", first_option)
            logging.info("Selected manufacturer: 'Scherer Voigt GbR'.")
            return True

        except Exception as e:
            logging.error("Error updating manufacturer: %s", e)
            return False

    def remove_rules_added(self):
        try:
            buttons = WebDriverWait(self.driver, 3).until(
                lambda d: d.find_elements(By.XPATH, "//button[.//span[text()='Delete pricing rule']]")
            )
            count = len(buttons)
            logging.info("Found %s buttons to delete pricing rules.", count)
            if count == 0:
                return True

            for i in range(count):
                buttons = self.driver.find_elements(By.XPATH, "//button[.//span[text()='Delete pricing rule']]")
                if buttons:
                    button_to_remove = buttons[0]
                    self.driver.execute_script("arguments[0].scrollIntoView(true);", button_to_remove)
                    self.driver.execute_script("arguments[0].click();", button_to_remove)
                    logging.info("Clicked delete pricing rule button (%s/%s).", i + 1, count)
                    time.sleep(0.5)
                else:
                    break
            return True

        except Exception as e:
            logging.info("No pricing rules found: %s", e)
            return False

    def select_conditional_rule(self, rule_text="Händler"):
        try:
            logging.info("Clicking conditional rule selector.")
            selection_div = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.CSS_SELECTOR, "div.sw-product-detail-context-prices__empty-state-select-rule div.sw-select__selection"
                ))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", selection_div)
            self.driver.execute_script("arguments[0].click();", selection_div)
            li_option = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.XPATH, f"//li[contains(@class, 'sw-select-result') and .//div[contains(@class, 'sw-highlight-text') and text()='{rule_text}']]"
                ))
            )
            li_option.click()
            logging.info("Selected conditional rule: %s", rule_text)
            return True
        except Exception as e:
            logging.error("Error selecting conditional rule: %s", e)
            return False

    def click_add_pricing_rule(self):
        try:
            logging.info("Clicking 'Add pricing rule' button.")
            add_rule_button = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.CSS_SELECTOR, "button.sw-product-detail-context-prices__add-new-rule"
                ))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", add_rule_button)
            self.driver.execute_script("arguments[0].click();", add_rule_button)
            logging.info("'Add pricing rule' button clicked.")
            return True
        except Exception as e:
            logging.error("Error clicking 'Add pricing rule': %s", e)
            return False

    def update_handler_preis(self, product_data):
        try:
            handler_preis = product_data.get("handler_preis")
            if handler_preis is None:
                logging.error("No 'handler_preis' in product_data.")
                return False

            inputs = WebDriverWait(self.driver, 20).until(
                lambda d: d.find_elements(By.XPATH, "//input[@name='sw-price-field-net' and @aria-label='Euro']")
            )
            logging.info("Found %s inputs to update price.", len(inputs))

            for input_field in inputs:
                current_value = input_field.get_attribute("value")
                if current_value and current_value.strip() != "":
                    input_field.clear()
                    input_field.send_keys(str(handler_preis))
                    logging.info("Updated input (previous value: %s) to: %s", current_value, handler_preis)
                else:
                    logging.info("Skipped input with no existing value.")

            return True

        except Exception as e:
            logging.error("Error updating 'handler_preis': %s", e)
            return False

    def select_pricing_rule_in_new_card(self, rule_text="Händler Ausland"):
        try:
            logging.info("Selecting rule in new pricing card.")
            rule_input = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.XPATH,
                    "//div[contains(@class, 'context-price') and contains(@class, 'context-price-group-1')]//input[@placeholder='Select a conditional rule...']"
                ))
            )
            rule_input.click()
            li_option = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.XPATH,
                    f"//li[contains(@class, 'sw-select-result') and .//div[contains(@class, 'sw-highlight-text') and normalize-space(text())='{rule_text}']]"
                ))
            )
            li_option.click()
            logging.info("Selected rule: %s", rule_text)
            return True
        except Exception as e:
            logging.error("Error selecting rule in new card: %s", e)
            return False

    def update_price_fields(self, product_data):
        try:
            endkunde_price = float(product_data.get("endkunde_preis", 0))
            gross_price = round(endkunde_price * 1.19, 2)
            adjusted_price = round(gross_price / 0.05) * 0.05
            adjusted_price = round(adjusted_price, 2)
            logging.info("Calculated gross price: %s, rounded to nearest 0.05: %s", gross_price, adjusted_price)

            gross_field = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.ID, "sw-price-field-gross"))
            )
            gross_field.clear()
            gross_field.send_keys(str(adjusted_price))
            logging.info("Gross price set to: %s", adjusted_price)
            return True
        except Exception as e:
            logging.error("Error updating gross price field: %s", e)
            return False

    def update_scaled_values(self, product_data):
        try:
            value_to_set = str(product_data.get("verpackungseinheit", "1"))
            groups = ["Händler", "Händler Ausland"]
            for group in groups:
                row_xpath = f"//tr[contains(@class, 'sw-data-grid__row') and .//span[normalize-space(text())='{group}']]"
                row = WebDriverWait(self.driver, 20).until(
                    EC.presence_of_element_located((By.XPATH, row_xpath))
                )
                logging.info("Found row for group: %s", group)
                actions = ActionChains(self.driver)
                min_cell = row.find_element(By.XPATH, ".//td[contains(@class, 'sw-data-grid__cell--minimumPurchase')]")
                self.driver.execute_script("arguments[0].scrollIntoView(true);", min_cell)
                actions.double_click(min_cell).perform()
                logging.info("Double-clicked Minimum purchase for group: %s", group)
                min_input = WebDriverWait(min_cell, 10).until(
                    EC.visibility_of_element_located((By.XPATH, ".//input[@aria-label='Minimum purchase']"))
                )
                min_input.clear()
                min_input.send_keys(value_to_set)
                logging.info("Set Minimum purchase for '%s' to %s", group, value_to_set)

                scaling_cell = row.find_element(By.XPATH, ".//td[contains(@class, 'sw-data-grid__cell--scaling')]")
                self.driver.execute_script("arguments[0].scrollIntoView(true);", scaling_cell)
                actions.double_click(scaling_cell).perform()
                logging.info("Double-clicked Scaling for group: %s", group)
                scaling_input = WebDriverWait(scaling_cell, 10).until(
                    EC.visibility_of_element_located((By.XPATH, ".//input[@aria-label='Scaling']"))
                )
                scaling_input.clear()
                scaling_input.send_keys(value_to_set)
                logging.info("Set Scaling for '%s' to %s", group, value_to_set)
            return True
        except Exception as e:
            logging.error("Error updating scaled values: %s", e)
            return False

    def update_sales_channels_selection(self):
        try:
            logging.info("Updating Sales Channels selection.")
            container = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, "div.sw-product-category-form__visibility_field"))
            )
            actions = ActionChains(self.driver)
            while True:
                selected_items = container.find_elements(
                    By.CSS_SELECTOR, "ul.sw-select-selection-list li.sw-select-selection-list__item-holder"
                )
                if not selected_items:
                    break
                for item in selected_items:
                    try:
                        actions.move_to_element(item).perform()
                        time.sleep(0.2)
                        remove_button = item.find_element(By.CSS_SELECTOR, "button.sw-label__dismiss")
                        self.driver.execute_script("arguments[0].scrollIntoView(true);", remove_button)
                        remove_button.click()
                        logging.info("Removed selected channel.")
                        time.sleep(0.2)
                    except Exception as e:
                        logging.error("Error removing channel: %s", e)
            logging.info("Cleared all selected channels.")

            expand_button = container.find_element(
                By.CSS_SELECTOR, "div.sw-select__selection-indicators span.sw-select__select-indicator-expand"
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", expand_button)
            self.driver.execute_script("arguments[0].click();", expand_button)
            logging.info("Expanded Sales Channels list.")
            result_list = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, "div.sw-select-result-list__content"))
            )
            options_list = result_list.find_element(By.CSS_SELECTOR, "ul.sw-select-result-list__item-list")
            option_selectors = [
                "li.sw-select-result.sw-select-option--0",
                "li.sw-select-result.sw-select-option--1",
                "li.sw-select-result.sw-select-option--2",
                "li.sw-select-result.sw-select-option--3"
            ]
            for sel in option_selectors:
                option = WebDriverWait(options_list, 10).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, sel))
                )
                self.driver.execute_script("arguments[0].scrollIntoView(true);", option)
                self.driver.execute_script("arguments[0].click();", option)
                logging.info("Clicked option %s", sel)
                time.sleep(0.2)
            return True
        except Exception as e:
            logging.error("Error updating Sales Channels: %s", e)
            return False

    def save_and_change_language(self, lang):
        try:
            logging.info("Opening language switch menu.")
            language_switch = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "div.sw-language-switch div.sw-select__selection"))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", language_switch)
            self.driver.execute_script("arguments[0].click();", language_switch)
            logging.info("Language switch menu opened.")
            if lang.upper() == "EN":
                selector = "//li[contains(@class, 'sw-select-result') and .//div[normalize-space(text())='English']]"
                option = WebDriverWait(self.driver, 10).until(
                    EC.element_to_be_clickable((By.XPATH, selector))
                )
            elif lang.upper() == "FR":
                selector = "//li[contains(@class, 'sw-select-result') and .//div[normalize-space(text())='Français']]"
                option = WebDriverWait(self.driver, 10).until(
                    EC.element_to_be_clickable((By.XPATH, selector))
                )
            elif lang.upper() == "DE":
                selector = "li.sw-select-result.sw-select-option--0"
                option = WebDriverWait(self.driver, 10).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, selector))
                )
            else:
                logging.error("Unknown language: %s", lang)
                return False
            self.driver.execute_script("arguments[0].scrollIntoView(true);", option)
            self.driver.execute_script("arguments[0].click();", option)
            logging.info("Selected language: %s", lang)
            try:
                modal_save_button = WebDriverWait(self.driver, 5).until(
                    EC.element_to_be_clickable((By.ID, "sw-language-switch-save-changes-button"))
                )
                self.driver.execute_script("arguments[0].scrollIntoView(true);", modal_save_button)
                self.driver.execute_script("arguments[0].click();", modal_save_button)
                logging.info("Clicked Save button in modal.")
            except Exception:
                logging.info("No save-changes modal appeared or was not needed.")
            return True
        except Exception as e:
            logging.error("Error in save_and_change_language: %s", e)
            return False

    def update_translated_text(self, product_data, lang):
        try:
            name_field = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.ID, "sw-field--product-name"))
            )
            name_field.clear()
            if lang.upper() == "EN":
                new_name = product_data.get("titel_GBR", "")
                new_desc = product_data.get("beschreibung_en", "")
            elif lang.upper() == "FR":
                new_name = product_data.get("titel_FRA", "")
                new_desc = product_data.get("beschreibung_fr", "")
            else:
                logging.error("Unknown language: %s", lang)
                return False
            name_field.send_keys(new_name)
            logging.info("Set Name to: %s", new_name)
            code_button = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.XPATH, "//div[contains(@class, 'sw-text-editor-toolbar-button__icon') and .//span[contains(@class, 'icon--regular-code-xs')]]"
                ))
            )
            if "is--active" not in code_button.get_attribute("class"):
                self.driver.execute_script("arguments[0].click();", code_button)
                logging.info("Switched editor to code mode.")
            else:
                logging.info("Editor already in code mode.")
            editor_div = WebDriverWait(self.driver, 20).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "div.sw-code-editor__editor.ace_editor"))
            )
            self.driver.execute_script("ace.edit(arguments[0]).setValue(arguments[1]);", editor_div, new_desc)
            logging.info("Set Description for language %s.", lang)
            return True
        except Exception as e:
            logging.error("Error updating translated text: %s", e)
            return False

    def search_product(self, product_data):
        try:
            search_input = WebDriverWait(self.driver, 20).until(
                EC.visibility_of_element_located((By.CSS_SELECTOR, "input.sw-search-bar__input"))
            )
            search_input.clear()
            artikelnummer = product_data.get("artikelnummer", "")
            if not artikelnummer:
                logging.error("No article number in product_data.")
                return False
            search_input.send_keys(artikelnummer)
            logging.info("Entered article number: %s", artikelnummer)
            time.sleep(1)
            result_link = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((
                    By.XPATH, f"//a[contains(@class, 'sw-search-bar-item__link') and .//span[contains(text(), '{artikelnummer}')]]"
                ))
            )
            self.driver.execute_script("arguments[0].scrollIntoView(true);", result_link)
            self.driver.execute_script("arguments[0].click();", result_link)
            logging.info("Clicked search result for article number: %s", artikelnummer)
            return True
        except Exception as e:
            logging.error("Error searching for product: %s", e)
            return False

    def go_to_shop(self, product_data):
        self.switch_to_shop()
        self.search_product(product_data)

    def run_sequence(self, product_data):
        self.switch_to_shop()
        self.go_to_tab("advanced pricing")
        self.remove_rules_added()
        self.select_conditional_rule()
        self.click_add_pricing_rule()
        self.select_pricing_rule_in_new_card()
        self.update_handler_preis(product_data)
        self.go_to_tab("general")
        self.update_manufacturer_selection()
        self.update_price_fields(product_data)
        self.update_scaled_values(product_data)
        self.update_sales_channels_selection()
        self.save_and_change_language("EN")
        self.update_translated_text(product_data, "EN")
        self.save_and_change_language("FR")
        self.update_translated_text(product_data, "FR")
        self.save_and_change_language("DE")


==== ./skrypt.py ====
import os

def save_files_content_to_txt(root_folder, output_file, ignore_dirs=None):
    """Rekurencyjnie odczytuje pliki .py w folderach, z pominięciem katalogów z ignore_dirs,
    i zapisuje ich treść do pliku tekstowego."""
    ignore_dirs = set(ignore_dirs or [])

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(root_folder):
            # Usuń z listy dirs te katalogi, których nazwy są na liście ignore_dirs
            dirs[:] = [d for d in dirs if d not in ignore_dirs]

            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            outfile.write(f"==== {file_path} ====\n")
                            outfile.write(infile.read())
                            outfile.write("\n\n")
                    except Exception as e:
                        print(f"Nie udało się odczytać pliku {file_path}: {e}")

if __name__ == "__main__":
    # Ścieżka, którą chcesz przeszukać
    input_folder = "./"
    output_file = "output.txt"
    # Tutaj wpisz nazwy folderów (tylko nazwa, nie ścieżka), które chcesz pominąć
    ignore_list = ['venv', '__pycache__', 'build']

    save_files_content_to_txt(input_folder, output_file, ignore_dirs=ignore_list)
    print(f"Zawartość plików została zapisana do {output_file}, z pominięciem katalogów: {ignore_list}")


==== ./translator.py ====
import logging
import deepl

class Translator:
    def __init__(self, config):
        self.auth_key = config["DEEPL_AUTH_KEY"]
        self.translator = deepl.Translator(self.auth_key)

    def translate_text(self, text, target_lang):
        try:
            result = self.translator.translate_text(text, target_lang=target_lang, tag_handling="html")
            logging.info("Translation to %s completed.", target_lang)
            return result.text
        except Exception as e:
            logging.error("Error during translation to %s: %s", target_lang, e)
            return ""

    def translate_product(self, product_data):
        description = product_data.get("beschreibung", "")
        if description:
            product_data["beschreibung_en"] = self.translate_text(description, "EN-GB")
            product_data["beschreibung_fr"] = self.translate_text(description, "FR")
        else:
            logging.warning("No product description to translate.")
        return product_data


